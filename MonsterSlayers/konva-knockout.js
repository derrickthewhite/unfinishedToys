// Generated by CoffeeScript 1.10.0

/*
Knockout Konva plugin version 0.1.5
Copyright 2014 Christopher Currie - https://github.com/christophercurrie
License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var hasProp = {}.hasOwnProperty;

  (function(factory) {
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
      return factory(require('knockout'), exports, require('konva'));
    } else if (typeof define === 'function' && define['amd']) {
      return define(['knockout', 'exports', 'konva'], factory);
    } else {
      return factory(ko, ko.konva = {}, Konva);
    }
  })(function(ko, exports, Konva) {
    var applyAnimations, applyEvents, applyInteractivityEventsCallback, ctor, expandConfig, getKonvaContainerIndex, makeBindingHandler, nodeFactory, nodeType, redraw, register;
    expandConfig = function(config) {
      var key, realValue, ref, result, value;
      result = {};
      ref = ko.utils.unwrapObservable(config);
      for (key in ref) {
        value = ref[key];
        realValue = ko.utils.unwrapObservable(value);
        if (typeof realValue !== 'undefined') {
          result[key] = realValue;
        }
      }
      return result;
    };
    applyAnimations = function(node, animations) {
      var fn1, key, value;
      fn1 = function(key, value) {
        var fn, trans;
        trans = null;
        if (typeof node[key] === 'function') {
          fn = function(value) {
            var error, error1;
            try {
              return node[key](value);
            } catch (error1) {
              error = error1;
            }
          };
          if (ko.isSubscribable(value)) {
            return value.subscribe(function(newValue) {
              if (trans) {
                trans.stop();
              }
              if (newValue) {
                return trans = fn(newValue);
              }
            });
          } else {
            if (value != null) {
              return fn(value);
            }
          }
        }
      };
      for (key in animations) {
        if (!hasProp.call(animations, key)) continue;
        value = animations[key];
        fn1(key, value);
      }
    };
    applyEvents = function(node, element, events) {
      var baseName, fn1, i, j, key, len, len1, listener, listeners, name, ref, removeEvents, value;
      removeEvents = [];
      ref = node.eventListeners;
      for (baseName in ref) {
        if (!hasProp.call(ref, baseName)) continue;
        listeners = ref[baseName];
        for (i = 0, len = listeners.length; i < len; i++) {
          listener = listeners[i];
          if (listener.name === 'knockout') {
            removeEvents.push(baseName);
          }
        }
      }
      for (j = 0, len1 = removeEvents.length; j < len1; j++) {
        name = removeEvents[j];
        node.off(name + ".knockout");
      }
      fn1 = function(key, value) {
        return node.on(key + ".knockout", function(evt) {
          return value(element, evt);
        });
      };
      for (key in events) {
        if (!hasProp.call(events, key)) continue;
        value = events[key];
        fn1(key, value);
      }
    };
    redraw = function(node) {
      var drawTarget, layer;
      if (node.getStage()) {
        drawTarget = (function() {
          var i, len, ref;
          if (node.nodeType === 'Stage') {
            ref = node.children;
            for (i = 0, len = ref.length; i < len; i++) {
              layer = ref[i];
              clearTimeout(layer._kktimeout);
            }
            return node;
          } else {
            return node.getLayer();
          }
        })();
        drawTarget = typeof node.draw === 'function' ? node : node.getLayer();
        clearTimeout(drawTarget._kktimeout);
        return drawTarget._kktimeout = setTimeout((function(drawTarget) {
          return function() {
            return drawTarget.draw();
          };
        })(drawTarget), 1);
      }
    };
    getKonvaContainerIndex = function(ancestor, element, state) {
      var child, isKonvaBinding, result;
      if (state == null) {
        state = {
          index: 0
        };
      }
      isKonvaBinding = function(e) {
        return e._kk != null;
      };
      child = ko.virtualElements.firstChild(ancestor);
      while (child != null) {
        if (child._kk === element._kk) {
          return state.index;
        }
        if (isKonvaBinding(child)) {
          state.index += 1;
        } else {
          result = getKonvaContainerIndex(child, element, state);
          if (result >= 0) {
            return result;
          }
        }
        child = ko.virtualElements.nextSibling(child);
      }
      return -1;
    };
    applyInteractivityEventsCallback = function(node, valueAccessor) {
		return node.on("click",function (clickEvent){
			attributes = node.getAttrs();
			values = valueAccessor();
			if(values.click) values.click(values.data,clickEvent);
		});
		/*
		return node.on("pointerup mouseup dragend mouseout", function() {
		var attr, attributes, values;
		attributes = node.getAttrs();
		values = valueAccessor();
		for (attr in attributes) {
		  if (!attributes.hasOwnProperty(attr)) {
			continue;
		  }
		  if (values.hasOwnProperty(attr) && ko.isObservable(values[attr])) {
			values[attr](attributes[attr]);
		  }
		}
		return null;
	  });
	  */
		
	};
    makeBindingHandler = function(nodeFactory) {
      return {
        init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
          var config, index, innerContext, kk, node, params;
          params = expandConfig(valueAccessor());
          config = params.config || params.animate || params.events ? params.config : params;
          node = nodeFactory(config, element.parentNode);
          element._kk = node;
          innerContext = bindingContext.createChildContext(viewModel);
          ko.utils.extend(innerContext, {
            'knockout-konva': {
              parentElement: element,
              parentNode: node
            }
          });
          ko.applyBindingsToDescendants(innerContext, element);
          applyInteractivityEventsCallback(node, valueAccessor);
          kk = bindingContext['knockout-konva'] || {};
          if (kk.parentNode) {
            kk.parentNode.add(node);
            index = getKonvaContainerIndex(kk.parentElement, element);
            if (index < 0) {
              throw new Error("element not contained within parent");
            }
            node.setZIndex(index);
          }
          ko.utils.domNodeDisposal.addDisposeCallback(element, (function(node) {
            return function() {
              var child, i, layer, len, parent, ref, results;
              parent = node.getParent();
              if (!parent) {
                return;
              }
              ref = parent.children;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (!(child === node)) {
                  continue;
                }
                node.remove();
                clearTimeout(node._kktimeout);
                layer = parent.getLayer();
                if (layer) {
                  redraw(layer);
                } else {
                  redraw(parent);
                }
                break;
              }
              return results;
            };
          })(node));
          if (element.style) {
            element.style.display = 'none';
          }
          applyAnimations(node, params.animate);
          applyEvents(node, element, params.events);
          return {
            controlsDescendantBindings: true
          };
        },
        update: function(element, valueAccessor) {
          var config, node, params, parent;
          node = element._kk;
          parent = node.getParent() || null;
          params = expandConfig(valueAccessor());
          config = params.config || params.events || params.animate ? params.config : params;
          node.setAttrs(config);
          applyAnimations(node, params.animate);
          applyEvents(node, element, params.events);
          if (parent) {
            redraw(parent);
          }
          return redraw(node);
        }
      };
    };
    register = function(name, factory) {
      ko.bindingHandlers[name] = makeBindingHandler(factory);
      return ko.virtualElements.allowedBindings[name] = true;
    };
    exports['register'] = register;
    for (nodeType in Konva) {
      ctor = Konva[nodeType];
      if (!(typeof ctor === 'function')) {
        continue;
      }
      nodeFactory = (function(nodeType, ctor) {
        if (nodeType === 'Stage') {
          return function(config, parent) {
            var div;
            div = document.createElement('div');
            parent.appendChild(div);
            config['container'] = div;
            return new ctor(config);
          };
        } else {
          return function(config) {
            return new ctor(config);
          };
        }
      })(nodeType, ctor);
      register("Konva." + nodeType, nodeFactory);
    }
  });

}).call(this);
